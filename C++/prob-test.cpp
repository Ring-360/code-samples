/**

	Модель системы вероятностных блоков.

	Система состоит из блоков.
	Каждый блок в системе может "сработать" с заранее известной вероятностью.
	Блоки могут быть соединены последовательно или параллельно и образовывать последовательно или параллельно соединённые цепочки.
	Всегда имеется единственная начальная и конечная точка.
	Считается, что система "сработала", если условный сигнал успешно прошёл от начальной до конечной точки хотя бы по одному из возможных маршрутов.
	Сигнал проходит успешно, если все блоки на его пути "сработали".

	Задача - путём моделирования определить эмпирическую вероятность срабатывания системы в трёх различных конфигурациях.
	(карта соединения блоков и вероятности их срабатывания заложены в код, при запуске не требует ввода данных, а только ведёт моделирование и выдаёт результат).
	Модель использовалась для проверки теоретических рассчётов вероятности срабатывания системы.
	
**/

#include <iostream>
#include <vector>
#include <random>
using namespace std;

class Node {
public:
	bool val;
	double p;
	vector<Node*> out;
	Node(double p_) : p(p_) {}
};

bool test(Node* a) {
	if (a->val == false)
		return false;
	if (a->out.size() == 0)
		return true;
	bool res;
	for (auto now : a->out) {
		res = test(now);
		if (res)
			break;
	}
	return res;
}

int main() {
	random_device rd;
	mt19937 gen(rd());
	uniform_real_distribution<> dis(0.0, 1.0);
	vector<Node*> a(12);
	vector<double> probs = { 1.0, 0.85, 0.8, 0.75, 0.7, 0.65, 0.6, 0.55, 0.5, 0.45, 0.4, 0.5 };
	for (int i = 0; i < a.size(); i++) {
		a[i] = new Node(probs[i]);
	}
	vector<vector<vector<int>>> outs = { { {1,7,8}, {11,2,3}, {4,5,6}, {4,5,6}, {}, {}, {}, {9}, {9}, {10}, {}, {} },
										 { {1,7,8,11}, {2,3}, {4,5,6}, {4,5,6}, {}, {}, {}, {9}, {9}, {10}, {}, {10} },
										 { {1,7,8}, {2,3}, {4,5,6}, {4,5,6}, {}, {}, {}, {9,11}, {9,11}, {10}, {}, {} } };
	for (int j = 0; j < 3; j++) {
		for (int i = 0; i < 12; i++) {
			vector<Node*> t;
			for (auto now : outs[j][i])
				t.push_back(a[now]);
			a[i]->out = t;
		}
		int count = 0;
		for (int i = 0; i < 1000000; i += 1) {
			for (auto now : a)
				now->val = dis(gen) < now->p;
			if (test(a[0]))
				count += 1;
		}
		cout << "Case " << j+1 << ":   P = " << count / 1000000.0 << endl;
	}
	return 0;
}